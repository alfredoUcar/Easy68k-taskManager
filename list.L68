0000117E Starting Address
Assembler used: EASy68K Editor/Assembler v5.9.0
Created On: 05/11/2013 20:22:28

00000000                             1  ************************************************************
00000000                             2  *                         LIST LIBRARY                     *
00000000                             3  *==========================================================*
00000000                             4  * LIST FORMAT DESCRIPTION:                                 *
00000000                             5  * A list is composed of:                                   *
00000000                             6  * - Header                                                 *
00000000                             7  *   + 1 WORD : List size (N)                               *
00000000                             8  *   + 1 WORD : Item size (M)                               *
00000000                             9  * - N data blocks, each one composed of:                   *
00000000                            10  *   + 1 WORD : Occupied field                              *
00000000                            11  *   + M WORDs : The data                                   *
00000000                            12  *                                                          *
00000000                            13  * The "occupied" field has two possible values:            *
00000000                            14  *   + $0000 : The data block is empty and can be used to   *
00000000                            15  *             put data                                     *
00000000                            16  *   + $FFFF : The data block is occupied and has data      *
00000000                            17  ************************************************************
00000000                            18  
00000000                            19  *-----------------------------------------------------------
00000000                            20  LS_INIT:
00000000                            21  * Description : Inits a list structure by setting to zero all 
00000000                            22  *               the occupied fields and filling the header.
00000000                            23  * Pre         : Stack. Specified stack offsets correspond to
00000000                            24  *               the stack state at the beginning of the sub-
00000000                            25  *               routine.
00000000                            26  *               Stack offsets from 0 to 3 contain the return 
00000000                            27  *               address.
00000000                            28  *                 - Offset 4: LONG: Pointer to the RAM area to 
00000000                            29  *                   store the list.
00000000                            30  *                 - Offset 8: WORD: List size.
00000000                            31  *                 - Offset 10: WORD: Item size (expressed in 
00000000                            32  *                   WORDs)
00000000                            33  * Post        : All registers are restored to their initial 
00000000                            34  *               values.
00000000                            35  * Note        : When calling this subroutine, the first
00000000                            36  *               parameter (the pointer) must point to a RAM 
00000000                            37  *               area with enough space to store the list. 
00000000                            38  *-----------------------------------------------------------
00000000                            39                  ; PUSH registers. Only the parts that may change are stored
00000000                            40                  ; to improve execution speed. 2 LONGs and 1 WORD is 10 bytes.
00000000                            41                  ; So, add 10 to the stack offsets.
00000000  48E7 4080                 42                  movem.l D1/A0, -(A7)    ; Store registers whose 32 bits may change
00000004  3F00                      43                  move.w  D0, -(A7)       ; Store registers whose 16 MSB won't change
00000006                            44  
00000006                            45                  ; Prepare registers
00000006  B381                      46                  eor.l   D1, D1          ; Put all D1 bits to zero. This register is going to be
00000008                            47                                          ; added, later, to an address register (32 bit). So, we
00000008                            48                                          ; have to ensure there is no trash in the 16 MSB.
00000008                            49                                          
00000008                            50                  ; Access to the stack parameters                        
00000008  206F 000E                 51                  move.l  14(A7), A0      ; List address
0000000C  302F 0012                 52                  move.w  18(A7), D0      ; List size
00000010  322F 0014                 53                  move.w  20(A7), D1      ; Item size
00000014                            54                  
00000014                            55                  ; Store list header
00000014  30C0                      56                  move.w  D0, (A0)+       ; Store list size
00000016  30C1                      57                  move.w  D1, (A0)+       ; Store item size
00000018                            58                  
00000018                            59                  ; Prepare registers before loop
00000018  E389                      60                  lsl.l   #1, D1          ; D1:=D1*2. Required as item size is expressed in WORDs
0000001A  5340                      61                  sub.w   #1, D0          ; Required as DBF loops N+1 times
0000001C                            62                  
0000001C                            63                  ; Loop through all data blocks and put zeros to the occupied field.
0000001C  30FC 0000                 64  .LOOP:          move.w  #0, (A0)+       ; Occupied field:=0
00000020  D1C1                      65                  adda.l  D1, A0          ; Go to the next data block
00000022  51C8 FFF8                 66                  dbf.w   D0, .LOOP
00000026                            67  
00000026                            68                  ; POP registers.                
00000026  301F                      69                  move.w  (A7)+, D0
00000028  4CDF 0102                 70                  movem.l (A7)+, D1/A0
0000002C  4E75                      71                  rts
0000002E                            72  *-----------------------------------------------------------
0000002E                            73  
0000002E                            74  *-----------------------------------------------------------
0000002E                            75  LS_PUT:
0000002E                            76  * Description : Puts the specified item in the first free 
0000002E                            77  *               position, if any.
0000002E                            78  * Pre         : Stack. Specified stack offsets correspond to
0000002E                            79  *               the stack state at the beginning of the sub-
0000002E                            80  *               routine.
0000002E                            81  *               Stack offsets from 0 to 3 contain the return 
0000002E                            82  *               address.
0000002E                            83  *                 - Offset 4: LONG: List pointer
0000002E                            84  *                 - Offset 8: M Words: Data to put in the list
0000002E                            85  * Post        : All registers are restored to their initial 
0000002E                            86  *               values.
0000002E                            87  *               Stack. The stack offsets specified now are
0000002E                            88  *               based on the same reference that the input ones.
0000002E                            89  *                 - Offset 4: LONG: Item pointer or $FFFFFFFF
0000002E                            90  *                   if item could not be included in the list.
0000002E                            91  *                   The pointer points to the data block. That
0000002E                            92  *                   is, to the occupied field of the data block.
0000002E                            93  * Note        : When calling this subroutine, the list is supposed
0000002E                            94  *               to be properly initialized.  
0000002E                            95  *-----------------------------------------------------------
0000002E                            96                  ; PUSH registers. 3 LONG + 3 WORD = 18 bytes. Add 18
0000002E                            97                  ; to all stack references
0000002E  48E7 40C0                 98                  movem.l D1/A0-A1, -(A7)
00000032  48A7 B000                 99                  movem.w D0/D2-D3, -(A7)
00000036                           100  
00000036                           101                  ; Get parameters and prepare registers
00000036  B381                     102                  eor.l   D1, D1          ; Put all D1 bits to zero               
00000038  206F 0016                103                  move.l  22(A7), A0      ; List address
0000003C  3018                     104                  move.w  (A0)+, D0       ; List size
0000003E  3218                     105                  move.w  (A0)+, D1       ; Item size
00000040  3401                     106                  move.w  D1, D2          ; Copy item size for future use
00000042  E389                     107                  lsl.l   #1, D1          ; D1:=D1*2 (size is specified in WORDs)
00000044  5340                     108                  sub.w   #1, D0          ; Required for DBF later
00000046                           109                  
00000046                           110                  ; Search for an empty slot
00000046  3618                     111  .LOOP:          move.w  (A0)+, D3       ; Occupied field
00000048  8643                     112                  or.w    D3, D3
0000004A  6700 0014                113                  beq     .SLOT_FOUND     ; If not occupied, put item
0000004E  D1C1                     114                  adda.l  D1, A0          ; If occupued, go to the next item
00000050  51C8 FFF4                115                  dbf.w   D0, .LOOP
00000054                           116  
00000054                           117                  ; If no empty slot, output $FFFFFFFF
00000054  2F7C FFFFFFFF 0016       118                  move.l  #$FFFFFFFF, 22(A7) ; No place for new item.
0000005C  6000 001E                119                  bra     .END
00000060                           120                  
00000060                           121                  ; If slot found, store output pointer
00000060  2248                     122  .SLOT_FOUND:    move.l  A0, A1          ; A0 points to the area to put the data
00000062  5589                     123                  suba.l  #2, A1          ; A1 points to the data block, including occupied field
00000064  2F49 0016                124                  move.l  A1, 22(A7)      ; Store the output pointer
00000068  32BC FFFF                125                  move.w  #$FFFF, (A1)    ; Mark as occupied
0000006C                           126  
0000006C                           127                  ; Prepare registers
0000006C  224F                     128                  move.l  A7, A1
0000006E  D3FC 0000001A            129                  adda.l  #26, A1         ; Now A1 points to the data in the stack                
00000074  5342                     130                  subq.w  #1, D2          ; Item size, in words, minus one to use in DBF
00000076                           131                  
00000076                           132                  ; Copy the data
00000076  30D9                     133  .LOOP2:         move.w  (A1)+, (A0)+    ; Copy data from stack to data block
00000078  51CA FFFC                134                  dbf.w   D2, .LOOP2
0000007C                           135                                  
0000007C                           136                  ; POP registers
0000007C  4C9F 000D                137  .END:           movem.w (A7)+, D0/D2-D3
00000080  4CDF 0302                138                  movem.l (A7)+, D1/A0-A1
00000084                           139  
00000084  4E75                     140                  rts             
00000086                           141  *-----------------------------------------------------------
00000086                           142                  
00000086                           143  *-----------------------------------------------------------
00000086                           144  LS_REMOVE:
00000086                           145  * Description : Removes the specified data block by putting
00000086                           146  *               a zero in the occupied field.
00000086                           147  * Pre         : Stack. Specified stack offsets correspond to
00000086                           148  *               the stack state at the beginning of the sub-
00000086                           149  *               routine.
00000086                           150  *               Stack offsets from 0 to 3 contain the return 
00000086                           151  *               address.
00000086                           152  *                 - Offset 4: LONG: Pointer to the data block to remove.
00000086                           153  * Post        : All registers are restored to their initial 
00000086                           154  *               values.
00000086                           155  * Note        : When calling this subroutine, the pointer is
00000086                           156  *               supposed to point to an item.
00000086                           157  *-----------------------------------------------------------
00000086                           158  
00000086  4E75                     159                  rts                             
00000088                           160  *-----------------------------------------------------------
00000088                           161  
00000088                           162  *-----------------------------------------------------------
00000088                           163  LS_FIRST:
00000088                           164  * Description : Outputs a pointer to the first occupied item
00000088                           165  *               or $FFFFFFFF if empty list.
00000088                           166  * Pre         : Stack. Specified stack offsets correspond to
00000088                           167  *               the stack state at the beginning of the sub-
00000088                           168  *               routine.
00000088                           169  *               Stack offsets from 0 to 3 contain the return 
00000088                           170  *               address.
00000088                           171  *                 - Offset 4: LONG: List pointer.
00000088                           172  * Post        : All registers are restored to their initial 
00000088                           173  *               values.
00000088                           174  *               Stack. The stack offsets specified now are
00000088                           175  *               based on the same reference that the input ones.
00000088                           176  *                 - Offset 4: LONG: Item pointer or $FFFFFFFF
00000088                           177  *                   if empty list.
00000088                           178  *                   The pointer points to the data block. That
00000088                           179  *                   is, to the occupied field of the data block.
00000088                           180  * Note        : When calling this subroutine, the pointer is
00000088                           181  *               supposed to point to a properly initialized list.
00000088                           182  *-----------------------------------------------------------
00000088                           183  
00000088                           184                  ; PUSH registers. 1 LONG + 2 WORD = 8 bytes. Add 8
00000088                           185                  ; to all stack references
00000088  48E7 0080                186                  movem.l A0, -(A7)
0000008C  48A7 6000                187                  movem.w D1-D2, -(A7)            
00000090                           188  
00000090  206F 000C                189                  move.l  12(A7), A0      ; guardamos el puntero a la lista
00000094  3218                     190                  move.w  (A0)+, D1       ; tamaño de lista (N)
00000096  3418                     191                  move.w  (A0)+, D2       ; tamaño de elemento (M)
00000098                           192                  ; nota: A0 apunta al primer elemento de la lista
00000098                           193  
00000098  48A7 6000                194                  movem.w D1-D2, -(A7)    ; paso de parametros
0000009C  48E7 0080                195                  movem.l A0, -(A7)
000000A0  4EB9 0000010C            196                  jsr     LS_ULTIMO_ELEMENTO              
000000A6  584F                     197                  add.w   #4, A7          ; POP de los parametros
000000A8                           198  
000000A8                           199          ; nota: (A7) contiene el resultado de la anterior subrutina
000000A8                           200          ; y se mantiene en la pila(sin hacer POP) para usarlo como parametro
000000A8                           201          ; en la siguiente subrutina
000000A8                           202                  
000000A8  2F08                     203                  move.l  A0, -(A7)       ;paso de parametros
000000AA  3F02                     204                  move.w  D2, -(A7)
000000AC  4EB9 00000134            205                  jsr     LS_BUSCA_OCUPADO
000000B2  206F 0008                206                  move.l  8(A7), A0       ; guarda resultado
000000B6  5C4F                     207                  add.w   #6, A7          ; POP de los parametros
000000B8                           208                  
000000B8  2F48 000C                209                  move.l  A0, 12(A7)      ;guarda el resultado en la pila
000000BC                           210  
000000BC                           211                  ; restaura los registros
000000BC  48A7 6000                212                  movem.w D1-D2, -(A7)
000000C0  48E7 0080                213                  movem.l A0, -(A7)               
000000C4  4E75                     214                  rts
000000C6                           215  *-----------------------------------------------------------
000000C6                           216                  
000000C6                           217  *-----------------------------------------------------------
000000C6                           218  LS_NEXT:
000000C6                           219  * Description : Given an item, outputs a pointer to the next 
000000C6                           220  *               occupied item or $FFFFFFFF if empty list.
000000C6                           221  * Pre         : Stack. Specified stack offsets correspond to
000000C6                           222  *               the stack state at the beginning of the sub-
000000C6                           223  *               routine.
000000C6                           224  *               Stack offsets from 0 to 3 contain the return 
000000C6                           225  *               address.
000000C6                           226  *                 - Offset 4: LONG: List pointer.
000000C6                           227  *                 - Offset 8: LONG: Current item pointer
000000C6                           228  * Post        : All registers are restored to their initial 
000000C6                           229  *               values.
000000C6                           230  *               Stack. The stack offsets specified now are
000000C6                           231  *               based on the same reference that the input ones.
000000C6                           232  *                 - Offset 8: LONG: Next item pointer or $FFFFFFFF
000000C6                           233  *                   if empty list.
000000C6                           234  *                   The pointer points to the data block. That
000000C6                           235  *                   is, to the occupied field of the data block.
000000C6                           236  * Note        : When calling this subroutine, the list pointer is
000000C6                           237  *               supposed to point to a properly initialized list.
000000C6                           238  *-----------------------------------------------------------
000000C6                           239  
000000C6                           240                  ; PUSH registers. 1 LONG + 2 WORD = 8 bytes. Add 8
000000C6                           241                  ; to all stack references
000000C6  48E7 0080                242                  movem.l A0, -(A7)
000000CA  48A7 6000                243                  movem.w D1-D2, -(A7)            
000000CE                           244  
000000CE  206F 000C                245                  move.l  12(A7), A0      ; guardamos el puntero a la lista
000000D2  3218                     246                  move.w  (A0)+, D1       ; tamaño de lista (N)
000000D4  3418                     247                  move.w  (A0)+, D2       ; tamaño de elemento (M)
000000D6  206F 0010                248                  move.l  16(A7), A0      ; A0 = puntero elemento actual
000000DA  D0C2                     249                  add.w   D2, A0
000000DC  5248                     250                  add.w   #1, A0          ; A0 = elemento siguiente
000000DE                           251  
000000DE  48A7 6000                252                  movem.w D1-D2, -(A7)    ; paso de parametros
000000E2  48E7 0080                253                  movem.l A0, -(A7)
000000E6  4EB9 0000010C            254                  jsr     LS_ULTIMO_ELEMENTO              
000000EC  584F                     255                  add.w   #4, A7          ; POP de los parametros
000000EE                           256  
000000EE                           257          ; nota: (A7) contiene el resultado de la anterior subrutina
000000EE                           258          ; y se mantiene en la pila(sin hacer POP) para usarlo como parametro
000000EE                           259          ; en la siguiente subrutina
000000EE                           260                  
000000EE  2F08                     261                  move.l  A0, -(A7)       ;paso de parametros
000000F0  3F02                     262                  move.w  D2, -(A7)
000000F2  4EB9 00000134            263                  jsr     LS_BUSCA_OCUPADO
000000F8  206F 0008                264                  move.l  8(A7), A0       ; guarda resultado
000000FC  5C4F                     265                  add.w   #6, A7          ; POP de los parametros
000000FE                           266                  
000000FE  2F48 000C                267                  move.l  A0, 12(A7)      ;guarda el resultado en la pila
00000102                           268  
00000102                           269                  ; restaura los registros
00000102  48A7 6000                270                  movem.w D1-D2, -(A7)
00000106  48E7 0080                271                  movem.l A0, -(A7)               
0000010A  4E75                     272                  rts     
0000010C                           273  *-------------------------------------------------------------
0000010C                           274  
0000010C                           275  
0000010C                           276  **************************************************************
0000010C                           277  ****               SUBRUTINAS AUXILIARES                  ****
0000010C                           278  **************************************************************
0000010C                           279  
0000010C                           280  *-------------------------------------------------------------
0000010C                           281  LS_ULTIMO_ELEMENTO:
0000010C                           282  * Subrutina de libreria para buscar el ultimo elemento de una lista.
0000010C                           283  * Pre:          Stack. Specified stack offsets correspond to
0000010C                           284  *               the stack state at the beginning of the sub-
0000010C                           285  *               routine.
0000010C                           286  *               Stack offsets from 0 to 3 contain the return 
0000010C                           287  *               address.
0000010C                           288  *                 - Offset 4:   puntero al primer elemento de la lista
0000010C                           289  *                 - Offset 8:   tamaño de la lista (N)
0000010C                           290  *                 - Offset 10:  tamaño de los elementos en words (M)
0000010C                           291  *
0000010C                           292  * Post:         El resultado se guarda en la misma posicion donde se
0000010C                           293  *               guardaba el puntero a la lista(Offset 4).
0000010C                           294  *--------------------------------------------------------------
0000010C                           295  
0000010C                           296                  ; PUSH registers. 1 LONG + 2 WORD = 8 bytes. Add 8
0000010C                           297                  ; to all stack references
0000010C  48E7 1000                298                  movem.l D3, -(A7)
00000110  48A7 6000                299                  movem.w D1-D2, -(A7)
00000114                           300  
00000114  322F 0012                301                  move.w  18(A7), D1      ; tamaño de elemento (M)
00000118  5241                     302                  add.w   #1, D1          ; D1 = M+1
0000011A  342F 0010                303                  move.w  16(A7), D2      ; tamaño de la lista (N)
0000011E  5342                     304                  sub.w   #1, D2          ; D2 = N-1
00000120  262F 000C                305                  move.l  12(A7), D3      ; puntero al primer elemento
00000124  E5AB                     306                  lsl.l   D2, D3          ; D3 = (N-1)*(M+1), ultimo elemento | que pasa si N-1=0 ??????
00000126  2F43 000C                307                  move.l  D3,12(A7)       ; guarda el resultado en la pila        
0000012A                           308                  
0000012A                           309                  ; POP registers
0000012A  4C9F 0006                310                  movem.w (A7)+, D1-D2
0000012E  4CDF 0008                311                  movem.l (A7)+, D3
00000132                           312                  
00000132  4E75                     313                  rts
00000134                           314  *--------------------------------------------------------------
00000134                           315  
00000134                           316  
00000134                           317  *-------------------------------------------------------------
00000134                           318  LS_BUSCA_OCUPADO:
00000134                           319  * Subrutina de biblioteca para buscar el primer el elemento ocupado de una lista
00000134                           320  * a partir de una posicion dada.
00000134                           321  * Pre:          -Offset 4: tamaño de los elementos en words (M)
00000134                           322  *               -Offset 6: puntero al elemento a partir del cual se busca
00000134                           323  *               -Offset 10: puntero al ultimo elemento de la lista
00000134                           324  *
00000134                           325  * Post:         -Offset 6: resultado. Puntero al elemento o #$FFFFFFFF
00000134                           326  *               si no lo ha encontrado.
00000134                           327  *--------------------------------------------------------------
00000134                           328  
00000134                           329                  ; PUSH registers. 1 LONG + 2 WORD = 8 bytes. Add 8
00000134                           330                  ; to all stack references
00000134  48E7 0060                331                  movem.l A1-A2, -(A7)
00000138  48A7 8000                332                  movem.w D0, -(A7)
0000013C                           333                  
0000013C  226F 0006                334                  move.l  6(A7),A1        ;elemento actual
00000140  246F 000A                335                  move.l  10(A7),A2       ;elemento final
00000144  302F 0004                336                  move.w  4(A7),D0        ;tamaño de los elementos (M)    
00000148  2F7C FFFFFFFF 0006       337                  move.l  #$FFFFFFFF,6(A7) ;inicializa resultado a 'no encontrado'
00000150  B4C9                     338  .LOOP:          cmp     A1,A2           ;A2<A1 => ha llegado al final de la lista sin encontrar nada
00000152  6D00 0014                339                  blt     .END            ;no encontrado
00000156  0C51 FFFF                340                  cmp     #$FFFF,(A1)     ;mira si est? ocupado
0000015A  6700 0008                341                  beq     .ENCONTRADO
0000015E  D2C0                     342                  add.w   D0,A1           ; A1+M => A1
00000160  5249                     343                  add.w   #1,A1           ; A1 = M+1
00000162  60EC                     344                  bra     .LOOP
00000164  2F49 0006                345  .ENCONTRADO:    move.l  A1,6(A7)        ;guarda la posici?n encontrada
00000168                           346  
00000168                           347  .END:           ; restaura los registros                
00000168  4C9F 0001                348                  movem.w (A7)+, D0
0000016C  4CDF 0600                349                  movem.l (A7)+, A1-A2
00000170                           350  
00000170  4E75                     351                  rts
00000172                           352  
00000172                           353          
00000172                           354  
00000172                           355  
00000172                           356  
00000172                           357  
Line 358 WARNING: END directive missing, starting address not set

No errors detected
1 warning generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
LS_BUSCA_OCUPADO    134
LS_BUSCA_OCUPADO:ENCONTRADO  164
LS_BUSCA_OCUPADO:END  168
LS_BUSCA_OCUPADO:LOOP  150
LS_FIRST            88
LS_INIT             0
LS_INIT:LOOP        1C
LS_NEXT             C6
LS_PUT              2E
LS_PUT:END          7C
LS_PUT:LOOP         46
LS_PUT:LOOP2        76
LS_PUT:SLOT_FOUND   60
LS_REMOVE           86
LS_ULTIMO_ELEMENTO  10C
